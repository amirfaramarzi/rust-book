## همزمانی با حالت مشترک

ارسال پیام یک روش خوب برای مدیریت همزمانی است، اما تنها روش نیست. روش دیگری می‌تواند این باشد که چندین Thread به یک داده مشترک دسترسی داشته باشند. دوباره به این بخش از شعار مستندات زبان Go فکر کنید: «از طریق اشتراک‌گذاری حافظه ارتباط برقرار نکنید.»

ارتباط از طریق اشتراک‌گذاری حافظه چگونه به نظر می‌رسد؟ علاوه بر این، چرا طرفداران ارسال پیام توصیه می‌کنند از اشتراک‌گذاری حافظه استفاده نکنید؟

به یک معنا، کانال‌ها در هر زبان برنامه‌نویسی شبیه به مالکیت یکتا هستند، زیرا زمانی که یک مقدار را از طریق یک کانال انتقال می‌دهید، نباید دیگر از آن مقدار استفاده کنید. همزمانی با حافظه مشترک شبیه به مالکیت چندگانه است: چندین Thread می‌توانند به طور همزمان به یک مکان حافظه دسترسی داشته باشند. همان‌طور که در فصل ۱۵ دیدید، جایی که اشاره‌گرهای هوشمند مالکیت چندگانه را ممکن می‌کردند، مالکیت چندگانه می‌تواند پیچیدگی ایجاد کند زیرا این مالک‌های مختلف نیاز به مدیریت دارند. سیستم نوع و قوانین مالکیت Rust به شدت در درست انجام دادن این مدیریت کمک می‌کنند. برای یک مثال، بیایید به Mutexها نگاه کنیم، یکی از رایج‌ترین عناصر ابتدایی همزمانی برای حافظه مشترک.

### استفاده از Mutexها برای اجازه دسترسی به داده توسط یک Thread در هر لحظه

_Mutex_ مخفف _mutual exclusion_ (حذف متقابل) است، به این معنا که یک Mutex فقط به یک Thread اجازه می‌دهد در هر لحظه به داده دسترسی داشته باشد. برای دسترسی به داده در یک Mutex، یک Thread باید ابتدا سیگنال دهد که می‌خواهد دسترسی داشته باشد، با درخواست برای به دست آوردن _قفل_ Mutex. قفل یک ساختار داده است که بخشی از Mutex است و پیگیری می‌کند که چه کسی در حال حاضر دسترسی انحصاری به داده دارد. بنابراین، Mutex به عنوان نگهبانی از داده‌ای که نگه می‌دارد از طریق سیستم قفل توصیف می‌شود.

Mutexها به دلیل سختی استفاده شهرت دارند زیرا باید دو قانون را به خاطر بسپارید:

- باید قبل از استفاده از داده، تلاش کنید قفل را به دست آورید.
- وقتی کارتان با داده‌ای که Mutex از آن محافظت می‌کند تمام شد، باید قفل را باز کنید تا سایر Threadها بتوانند قفل را به دست آورند.

برای یک استعاره واقعی از Mutex، یک میزگرد در یک کنفرانس را تصور کنید که فقط یک میکروفون دارد. قبل از اینکه یک شرکت‌کننده بتواند صحبت کند، باید درخواست کند یا سیگنال دهد که می‌خواهد از میکروفون استفاده کند. وقتی میکروفون را به دست می‌آورد، می‌تواند هر چقدر که بخواهد صحبت کند و سپس میکروفون را به شرکت‌کننده بعدی که درخواست صحبت کرده است، بدهد. اگر یک شرکت‌کننده فراموش کند میکروفون را پس بدهد، هیچ‌کس دیگری نمی‌تواند صحبت کند. اگر مدیریت میکروفون مشترک درست انجام نشود، میزگرد طبق برنامه کار نخواهد کرد!

مدیریت Mutexها می‌تواند به طرز باور نکردنی دشوار باشد، به همین دلیل بسیاری از افراد به کانال‌ها علاقه‌مند هستند. با این حال، به لطف سیستم نوع و قوانین مالکیت Rust، نمی‌توانید در قفل کردن و باز کردن قفل اشتباه کنید.

#### API `Mutex<T>`

برای مثالی از نحوه استفاده از Mutex، بیایید با استفاده از یک Mutex در یک زمینه تک‌Threadی شروع کنیم، همان‌طور که در لیست ۱۶-۱۲ نشان داده شده است:

<Listing number="16-12" file-name="src/main.rs" caption="Exploring the API of `Mutex<T>` in a single-threaded context for simplicity">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-12/src/main.rs}}
```

</Listing>

همان‌طور که با بسیاری از نوع‌ها مشاهده می‌شود، یک `Mutex<T>` را با استفاده از تابع وابسته `new` ایجاد می‌کنیم. برای دسترسی به داده داخل Mutex، از متد `lock` استفاده می‌کنیم تا قفل را به دست آوریم. این فراخوانی Thread فعلی را متوقف می‌کند، بنابراین نمی‌تواند کاری انجام دهد تا زمانی که نوبت ما برای گرفتن قفل برسد.

فراخوانی `lock` در صورتی که یک Thread دیگر که قفل را نگه داشته دچار وحشت (_panic_) شود، شکست می‌خورد. در چنین حالتی، هیچ‌کس دیگر نمی‌تواند قفل را به دست آورد، بنابراین انتخاب کرده‌ایم که از `unwrap` استفاده کنیم و اگر در چنین وضعیتی قرار گرفتیم، این Thread نیز دچار وحشت شود.

بعد از گرفتن قفل، می‌توانیم مقدار بازگردانده‌شده را، که در اینجا به نام `num` است، به عنوان یک مرجع قابل تغییر به داده داخل در نظر بگیریم. سیستم نوع تضمین می‌کند که قبل از استفاده از مقدار داخل `m` قفل را به دست آوریم. نوع `m` برابر با `Mutex<i32>` است، نه `i32`، بنابراین _باید_ برای استفاده از مقدار `i32`، متد `lock` را فراخوانی کنیم. نمی‌توانیم فراموش کنیم؛ سیستم نوع اجازه دسترسی به مقدار داخلی `i32` را به ما نمی‌دهد.

همان‌طور که احتمالاً حدس می‌زنید، `Mutex<T>` یک اشاره‌گر هوشمند است. دقیق‌تر، فراخوانی `lock` یک اشاره‌گر هوشمند به نام `MutexGuard` را بازمی‌گرداند، که در یک `LockResult` بسته‌بندی شده است و آن را با فراخوانی `unwrap` مدیریت کردیم. اشاره‌گر هوشمند `MutexGuard` ویژگی `Deref` را پیاده‌سازی می‌کند تا به داده داخلی ما اشاره کند. همچنین، این اشاره‌گر هوشمند یک پیاده‌سازی از `Drop` دارد که به‌طور خودکار قفل را زمانی که یک `MutexGuard` از محدوده خارج می‌شود، آزاد می‌کند، که این اتفاق در انتهای محدوده داخلی رخ می‌دهد. در نتیجه، خطر فراموش کردن آزاد کردن قفل و جلوگیری از استفاده دیگر Threadها از Mutex وجود ندارد، زیرا آزادسازی قفل به صورت خودکار انجام می‌شود.

پس از آزاد کردن قفل، می‌توانیم مقدار Mutex را چاپ کنیم و ببینیم که توانستیم مقدار داخلی `i32` را به ۶ تغییر دهیم.

#### اشتراک‌گذاری یک `Mutex<T>` بین چندین Thread

حالا، بیایید تلاش کنیم یک مقدار را بین چندین Thread با استفاده از `Mutex<T>` به اشتراک بگذاریم. ما ۱۰ Thread ایجاد خواهیم کرد و هرکدام مقدار شمارنده را ۱ واحد افزایش می‌دهند، بنابراین شمارنده از ۰ به ۱۰ می‌رسد. مثال بعدی در لیست ۱۶-۱۳ دارای خطای کامپایل خواهد بود، و از آن خطا برای یادگیری بیشتر در مورد استفاده از `Mutex<T>` و اینکه چگونه Rust به ما کمک می‌کند از آن به درستی استفاده کنیم، استفاده خواهیم کرد.

<Listing number="16-13" file-name="src/main.rs" caption="Ten threads each increment a counter guarded by a `Mutex<T>`">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-13/src/main.rs}}
```

</Listing>

ما یک متغیر `counter` ایجاد می‌کنیم تا یک مقدار `i32` را در یک `Mutex<T>` نگه دارد، همان‌طور که در لیست ۱۶-۱۲ انجام دادیم. سپس، با تکرار روی یک بازه عددی، ۱۰ Thread ایجاد می‌کنیم. از `thread::spawn` استفاده می‌کنیم و به تمام Threadها یک Closure یکسان می‌دهیم: یک Closure که متغیر `counter` را به Thread منتقل می‌کند، قفل `Mutex<T>` را با فراخوانی متد `lock` به دست می‌آورد، و سپس ۱ واحد به مقدار داخل Mutex اضافه می‌کند. وقتی یک Thread اجرای Closure خود را تمام می‌کند، `num` از محدوده خارج شده و قفل را آزاد می‌کند تا Thread دیگری بتواند آن را به دست آورد.

در Thread اصلی، تمام handleهای join را جمع‌آوری می‌کنیم. سپس، همان‌طور که در لیست ۱۶-۲ انجام دادیم، متد `join` را روی هر handle فراخوانی می‌کنیم تا مطمئن شویم تمام Threadها تمام شده‌اند. در آن نقطه، Thread اصلی قفل را به دست می‌آورد و نتیجه این برنامه را چاپ می‌کند.

ما اشاره کردیم که این مثال کامپایل نخواهد شد. حالا بیایید ببینیم چرا!

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-13/output.txt}}
```

پیام خطا نشان می‌دهد که مقدار `counter` در تکرار قبلی حلقه منتقل شده است. Rust به ما می‌گوید که نمی‌توانیم مالکیت `counter` را به چندین Thread منتقل کنیم. بیایید این خطای کامپایلر را با استفاده از روش مالکیت چندگانه که در فصل ۱۵ بحث کردیم، برطرف کنیم.

#### مالکیت چندگانه با چندین Thread

در فصل ۱۵، ما با استفاده از اشاره‌گر هوشمند `Rc<T>` برای ایجاد یک مقدار شمارش‌شده توسط مرجع (_reference-counted value_) به یک مقدار چندین مالک دادیم. بیایید همین کار را اینجا انجام دهیم و ببینیم چه اتفاقی می‌افتد. ما `Mutex<T>` را در `Rc<T>` بسته‌بندی می‌کنیم (همان‌طور که در لیست ۱۶-۱۴ نشان داده شده است) و قبل از انتقال مالکیت به Thread، `Rc<T>` را کلون می‌کنیم.

<Listing number="16-14" file-name="src/main.rs" caption="تلاش برای استفاده از `Rc<T>` برای اجازه مالکیت چندگانه `Mutex<T>` توسط چندین Thread">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-14/src/main.rs}}
```

</Listing>

دوباره کامپایل می‌کنیم و... خطاهای متفاوتی دریافت می‌کنیم! کامپایلر چیزهای زیادی به ما یاد می‌دهد.

```console
{{#include ../listings/ch16-fearless-concurrency/listing-16-14/output.txt}}
```

وای، این پیام خطا بسیار طولانی است! اما بخش مهمی که باید روی آن تمرکز کنیم این است:  
`` `Rc<Mutex<i32>>` cannot be sent between threads safely ``.  
کامپایلر همچنین دلیل آن را به ما می‌گوید:  
`` the trait `Send` is not implemented for `Rc<Mutex<i32>>` ``.  

ما در بخش بعدی درباره `Send` صحبت خواهیم کرد: یکی از ویژگی‌هایی که اطمینان می‌دهد نوع‌هایی که با Threadها استفاده می‌کنیم برای استفاده در شرایط همزمان طراحی شده‌اند.

متأسفانه، `Rc<T>` برای اشتراک‌گذاری بین Threadها ایمن نیست. وقتی `Rc<T>` شمارش مرجع را مدیریت می‌کند، برای هر فراخوانی به `clone` به شمارش اضافه می‌کند و وقتی هر کلون حذف می‌شود، از شمارش کم می‌کند. اما از هیچ ابزار همزمانی استفاده نمی‌کند تا مطمئن شود که تغییرات در شمارش نمی‌توانند توسط یک Thread دیگر قطع شوند. این می‌تواند به شمارش‌های اشتباه منجر شود—باگ‌های ظریفی که ممکن است باعث نشت حافظه یا حذف یک مقدار قبل از اتمام کار ما با آن شوند. چیزی که نیاز داریم، نوعی دقیقاً مانند `Rc<T>` است، اما یکی که تغییرات شمارش مرجع را به صورت ایمن در برابر Thread مدیریت کند.

#### شمارش مرجع اتمی با `Arc<T>`

خوشبختانه، `Arc<T>` یک نوع مشابه `Rc<T>` است که برای استفاده در شرایط همزمان ایمن است. حرف _a_ در `Arc` مخفف _atomic_ است، به این معنا که یک نوع _شمارش مرجع اتمی_ است. اتمیک‌ها نوع دیگری از عناصر ابتدایی همزمانی هستند که در اینجا به‌طور مفصل به آن‌ها نمی‌پردازیم؛ برای جزئیات بیشتر به مستندات کتابخانه استاندارد در مورد [`std::sync::atomic`][atomic]<!-- ignore --> مراجعه کنید. در این مرحله، فقط باید بدانید که اتمیک‌ها مانند نوع‌های ابتدایی کار می‌کنند اما برای اشتراک‌گذاری بین Threadها ایمن هستند.

شاید از خود بپرسید چرا تمام نوع‌های ابتدایی اتمی نیستند و چرا نوع‌های کتابخانه استاندارد به‌طور پیش‌فرض از `Arc<T>` استفاده نمی‌کنند. دلیل این است که ایمنی Thread با یک هزینه عملکردی همراه است که فقط زمانی که واقعاً نیاز باشد، می‌خواهید آن را پرداخت کنید. اگر فقط روی مقادیر در یک Thread واحد عملیات انجام می‌دهید، کد شما می‌تواند سریع‌تر اجرا شود اگر مجبور به اعمال تضمین‌های اتمیک نباشد.

بیایید به مثال خود برگردیم: `Arc<T>` و `Rc<T>` API یکسانی دارند، بنابراین برنامه خود را با تغییر خط `use`، فراخوانی `new`، و فراخوانی `clone` اصلاح می‌کنیم. کد موجود در لیست ۱۶-۱۵ در نهایت کامپایل و اجرا می‌شود:

<Listing number="16-15" file-name="src/main.rs" caption="استفاده از `Arc<T>` برای بسته‌بندی `Mutex<T>` جهت اشتراک مالکیت بین چندین Thread">

```rust
{{#rustdoc_include ../listings/ch16-fearless-concurrency/listing-16-15/src/main.rs}}
```

</Listing>

این کد خروجی زیر را چاپ می‌کند:

```text
Result: 10
```

ما موفق شدیم! شمارنده را از ۰ به ۱۰ افزایش دادیم که ممکن است خیلی چشمگیر به نظر نرسد، اما چیزهای زیادی درباره `Mutex<T>` و ایمنی Thread یاد گرفتیم. همچنین می‌توانید از ساختار این برنامه برای انجام عملیات پیچیده‌تری به‌جز افزایش یک شمارنده استفاده کنید. با استفاده از این استراتژی، می‌توانید یک محاسبه را به بخش‌های مستقل تقسیم کنید، این بخش‌ها را بین Threadها تقسیم کنید، و سپس از یک `Mutex<T>` استفاده کنید تا هر Thread نتیجه نهایی را با بخش مربوط به خودش به‌روزرسانی کند.

توجه داشته باشید که اگر در حال انجام عملیات عددی ساده هستید، نوع‌های ساده‌تری نسبت به `Mutex<T>` در ماژول [`std::sync::atomic` از کتابخانه استاندارد][atomic]<!-- ignore --> ارائه شده‌اند. این نوع‌ها دسترسی اتمی، ایمن و همزمان به نوع‌های ابتدایی فراهم می‌کنند. ما برای این مثال از `Mutex<T>` با یک نوع ابتدایی استفاده کردیم تا بتوانیم بر نحوه کار `Mutex<T>` تمرکز کنیم.

### شباهت‌های بین `RefCell<T>`/`Rc<T>` و `Mutex<T>`/`Arc<T>`

ممکن است متوجه شده باشید که `counter` تغییرناپذیر است، اما توانستیم یک مرجع قابل تغییر به مقدار داخل آن بگیریم؛ این بدان معناست که `Mutex<T>` قابلیت تغییر داخلی (_interior mutability_) را فراهم می‌کند، همان‌طور که خانواده `Cell` این کار را می‌کنند. به همان شکلی که در فصل ۱۵ از `RefCell<T>` برای اجازه تغییر محتوا درون یک `Rc<T>` استفاده کردیم، از `Mutex<T>` برای تغییر محتوا درون یک `Arc<T>` استفاده می‌کنیم.

نکته دیگری که باید توجه کنید این است که Rust نمی‌تواند شما را از تمام انواع خطاهای منطقی هنگام استفاده از `Mutex<T>` محافظت کند. به یاد بیاورید که در فصل ۱۵ استفاده از `Rc<T>` با خطر ایجاد چرخه‌های مرجع همراه بود، جایی که دو مقدار `Rc<T>` به یکدیگر ارجاع می‌دادند و باعث نشت حافظه می‌شدند. به‌طور مشابه، `Mutex<T>` با خطر ایجاد _بن‌بست_ (_deadlock_) همراه است. این وضعیت زمانی رخ می‌دهد که یک عملیات نیاز به قفل کردن دو منبع دارد و دو Thread هر کدام یکی از قفل‌ها را به دست آورده‌اند و باعث می‌شوند که برای همیشه منتظر یکدیگر بمانند. اگر به بن‌بست علاقه دارید، سعی کنید یک برنامه Rust ایجاد کنید که دچار بن‌بست شود؛ سپس استراتژی‌های کاهش بن‌بست برای Mutexها در هر زبانی را تحقیق کنید و آن‌ها را در Rust پیاده‌سازی کنید. مستندات API کتابخانه استاندارد برای `Mutex<T>` و `MutexGuard` اطلاعات مفیدی ارائه می‌دهد.

ما این فصل را با صحبت درباره ویژگی‌های `Send` و `Sync` و نحوه استفاده از آن‌ها با نوع‌های سفارشی تکمیل خواهیم کرد.

[atomic]: https://doc.rust-lang.org/std/sync/atomic/index.html
