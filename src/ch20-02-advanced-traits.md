## Advanced Traits

ما در بخش [“Traits: Defining Shared Behavior”][traits-defining-shared-behavior]<!-- ignore --> از فصل 10 به بررسی traits پرداختیم، اما جزئیات پیشرفته‌تر آن را مورد بحث قرار ندادیم. اکنون که اطلاعات بیشتری در مورد راست دارید، می‌توانیم به عمق موضوع بپردازیم.

### Specifying Placeholder Types in Trait Definitions with Associated Types

_نوع‌های مرتبط_ (Associated types) یک نوع جایگزین را با یک trait متصل می‌کنند، به‌گونه‌ای که تعریف‌های متد trait می‌توانند از این نوع‌های جایگزین در امضاهای خود استفاده کنند. پیاده‌ساز یک trait نوع خاصی را برای جایگزینی نوع جایگزین برای پیاده‌سازی خاص مشخص می‌کند. به این ترتیب، می‌توانیم یک trait تعریف کنیم که از برخی نوع‌ها استفاده می‌کند بدون اینکه نیاز داشته باشیم دقیقاً بدانیم این نوع‌ها چه هستند تا زمانی که trait پیاده‌سازی شود.

بیشتر ویژگی‌های پیشرفته‌ای که در این فصل توضیح داده شده است، به‌ندرت مورد نیاز هستند. نوع‌های مرتبط در حد وسط قرار دارند: آن‌ها کمتر از ویژگی‌های توضیح داده‌شده در بقیه کتاب استفاده می‌شوند، اما بیشتر از بسیاری از ویژگی‌های دیگر مورد بحث در این فصل به کار می‌روند.

یکی از مثال‌های یک trait با یک نوع مرتبط، trait `Iterator` است که کتابخانه استاندارد فراهم می‌کند. نوع مرتبط با نام `Item` مشخص شده و به‌جای نوع مقادیری که نوع پیاده‌سازی‌کننده `Iterator` از روی آن‌ها تکرار می‌کند قرار می‌گیرد. تعریف trait `Iterator` همان‌طور که در فهرست 20-13 نشان داده شده است:

<Listing number="20-13" caption="تعریف trait `Iterator` که دارای یک نوع مرتبط به نام `Item` است">

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-13/src/lib.rs}}
```

</Listing>

نوع `Item` یک جایگزین است و تعریف متد `next` نشان می‌دهد که مقادیری از نوع `Option<Self::Item>` را بازمی‌گرداند. پیاده‌سازان trait `Iterator` نوع خاصی را برای `Item` مشخص می‌کنند و متد `next` یک `Option` حاوی مقدار از آن نوع خاص بازمی‌گرداند.

نوع‌های مرتبط ممکن است مفهومی مشابه با genericها به نظر برسند، به این معنا که genericها به ما اجازه می‌دهند یک تابع بدون مشخص کردن نوع‌هایی که می‌تواند با آن‌ها کار کند، تعریف کنیم. برای بررسی تفاوت بین این دو مفهوم، به یک پیاده‌سازی trait `Iterator` روی یک نوع به نام `Counter` نگاه خواهیم کرد که نوع `Item` را به‌عنوان `u32` مشخص می‌کند:

<Listing file-name="src/lib.rs">

```rust,ignore
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-22-iterator-on-counter/src/lib.rs:ch19}}
```

</Listing>

این سینتکس با سینتکس genericها قابل مقایسه به نظر می‌رسد. پس چرا به جای این کار، trait `Iterator` را با استفاده از genericها تعریف نکنیم، همان‌طور که در فهرست 20-14 نشان داده شده است؟

<Listing number="20-14" caption="یک تعریف فرضی از trait `Iterator` با استفاده از genericها"> 

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-14/src/lib.rs}}
```

</Listing>

تفاوت این است که هنگام استفاده از genericها، همان‌طور که در فهرست 20-14 نشان داده شده است، ما باید نوع‌ها را در هر پیاده‌سازی حاشیه‌نویسی کنیم. زیرا می‌توانیم همچنین `Iterator<String> for Counter` یا هر نوع دیگری را پیاده‌سازی کنیم، به‌طوری که بتوانیم پیاده‌سازی‌های متعددی از `Iterator` برای `Counter` داشته باشیم. به عبارت دیگر، زمانی که یک trait یک پارامتر generic دارد، می‌تواند برای یک نوع چندین بار پیاده‌سازی شود و نوع‌های خاص پارامترهای generic را هر بار تغییر دهد. زمانی که ما از متد `next` بر روی `Counter` استفاده می‌کنیم، باید حاشیه‌نویسی نوع ارائه دهیم تا مشخص کنیم کدام پیاده‌سازی `Iterator` را می‌خواهیم استفاده کنیم.

با استفاده از نوع‌های مرتبط، نیازی به حاشیه‌نویسی نوع‌ها نداریم زیرا نمی‌توانیم یک trait را بر روی یک نوع چندین بار پیاده‌سازی کنیم. در فهرست 20-13 با تعریفی که از نوع‌های مرتبط استفاده می‌کند، ما فقط می‌توانیم نوع `Item` را یک بار انتخاب کنیم، زیرا تنها یک `impl Iterator for Counter` می‌تواند وجود داشته باشد. ما نیازی نداریم که مشخص کنیم می‌خواهیم یک iterator از مقادیر `u32` داشته باشیم در هر جایی که `next` را بر روی `Counter` فراخوانی می‌کنیم.

نوع‌های مرتبط همچنین بخشی از قرارداد trait می‌شوند: پیاده‌سازان trait باید یک نوع ارائه دهند تا جایگزین نوع جایگزین مرتبط شود. نوع‌های مرتبط اغلب نامی دارند که توصیف می‌کند چگونه نوع استفاده خواهد شد و مستندسازی نوع مرتبط در مستندات API یک عمل خوب است.

### Default Generic Type Parameters and Operator Overloading

وقتی که از پارامترهای generic type استفاده می‌کنیم، می‌توانیم یک نوع خاص پیش‌فرض برای پارامتر generic تعیین کنیم. این نیاز به مشخص کردن یک نوع خاص توسط پیاده‌سازان trait را در صورتی که نوع پیش‌فرض کار کند، از بین می‌برد. شما می‌توانید هنگام اعلام یک نوع generic، یک نوع پیش‌فرض با سینتکس `<PlaceholderType=ConcreteType>` مشخص کنید.

یک مثال عالی از وضعیتی که این تکنیک مفید است، _بارگذاری مجدد عملگرها_ است، جایی که شما رفتار یک عملگر (مانند `+`) را در شرایط خاص شخصی‌سازی می‌کنید.

راست به شما اجازه نمی‌دهد عملگرهای خود را ایجاد کنید یا عملگرهای دلخواه را بارگذاری مجدد کنید. اما می‌توانید عملیات‌ها و traits مربوط به آن‌ها را که در `std::ops` فهرست شده‌اند با پیاده‌سازی traits مرتبط با عملگر، بارگذاری مجدد کنید. برای مثال، در فهرست 20-15 ما عملگر `+` را برای اضافه کردن دو نمونه `Point` به یکدیگر بارگذاری مجدد می‌کنیم. ما این کار را با پیاده‌سازی trait `Add` بر روی struct `Point` انجام می‌دهیم:

<Listing number="20-15" file-name="src/main.rs" caption="پیاده‌سازی trait `Add` برای بارگذاری مجدد عملگر `+` برای نمونه‌های `Point`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-15/src/main.rs}}
```

</Listing>

متد `add` مقادیر `x` دو نمونه `Point` و مقادیر `y` دو نمونه `Point` را اضافه می‌کند تا یک نمونه جدید از `Point` ایجاد کند. trait `Add` دارای یک نوع مرتبط با نام `Output` است که نوع بازگشتی از متد `add` را تعیین می‌کند.

نوع generic پیش‌فرض در این کد در داخل trait `Add` است. در اینجا تعریف آن آمده است:

```rust
trait Add<Rhs=Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}
```

این کد باید به طور کلی آشنا به نظر برسد: یک trait با یک متد و یک نوع مرتبط. بخش جدید `Rhs=Self` است: این سینتکس به _default type parameters_ یا "پارامترهای نوع پیش‌فرض" معروف است. پارامتر generic نوع `Rhs` (مخفف "right hand side" یا "سمت راست") نوع پارامتر `rhs` را در متد `add` تعریف می‌کند. اگر هنگام پیاده‌سازی trait `Add` یک نوع خاص برای `Rhs` مشخص نکنیم، نوع `Rhs` به طور پیش‌فرض به `Self` تنظیم می‌شود، که نوعی خواهد بود که ما `Add` را بر روی آن پیاده‌سازی می‌کنیم.

هنگامی که `Add` را برای `Point` پیاده‌سازی کردیم، از پیش‌فرض برای `Rhs` استفاده کردیم زیرا می‌خواستیم دو نمونه `Point` را به هم اضافه کنیم. حال، بیایید به مثالی از پیاده‌سازی trait `Add` نگاه کنیم که در آن می‌خواهیم نوع `Rhs` را شخصی‌سازی کنیم و از پیش‌فرض استفاده نکنیم.

ما دو struct به نام‌های `Millimeters` و `Meters` داریم که مقادیر را در واحدهای مختلف نگه می‌دارند. این نوع نازک‌سازی یک نوع موجود در یک struct دیگر به‌عنوان الگوی _newtype pattern_ شناخته می‌شود که ما آن را در بخش [“Using the Newtype Pattern to Implement External Traits on External Types”][newtype]<!-- ignore --> به‌طور مفصل توضیح می‌دهیم. ما می‌خواهیم مقادیر میلی‌متر را به مقادیر متر اضافه کنیم و پیاده‌سازی `Add` تبدیل را به‌درستی انجام دهد. می‌توانیم `Add` را برای `Millimeters` با `Meters` به‌عنوان `Rhs` همان‌طور که در فهرست 20-16 نشان داده شده است، پیاده‌سازی کنیم.

<Listing number="20-16" file-name="src/lib.rs" caption="پیاده‌سازی trait `Add` برای `Millimeters` جهت افزودن `Millimeters` به `Meters`">

```rust,noplayground
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-16/src/lib.rs}}
```

</Listing>

برای افزودن `Millimeters` و `Meters`، ما `impl Add<Meters>` را مشخص می‌کنیم تا مقدار پارامتر نوع `Rhs` را به جای استفاده از پیش‌فرض `Self` تنظیم کنیم.

شما از پارامترهای نوع پیش‌فرض در دو حالت اصلی استفاده خواهید کرد:

- برای گسترش یک نوع بدون شکستن کد موجود
- برای اجازه دادن به شخصی‌سازی در موارد خاص که اکثر کاربران به آن نیازی ندارند

trait `Add` در کتابخانه استاندارد یک مثال از هدف دوم است: معمولاً شما دو نوع مشابه را اضافه خواهید کرد، اما trait `Add` قابلیت شخصی‌سازی فراتر از آن را فراهم می‌کند. استفاده از پارامتر نوع پیش‌فرض در تعریف trait `Add` به این معناست که شما بیشتر اوقات نیازی به مشخص کردن پارامتر اضافی ندارید. به عبارت دیگر، مقدار کمی از کد اضافی حذف می‌شود و استفاده از trait آسان‌تر می‌شود.

هدف اول مشابه هدف دوم است، اما به‌صورت معکوس: اگر بخواهید یک پارامتر نوع را به یک trait موجود اضافه کنید، می‌توانید برای گسترش قابلیت‌های trait بدون شکستن کد پیاده‌سازی موجود، یک مقدار پیش‌فرض برای آن تنظیم کنید.

### Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name

در راست هیچ محدودیتی برای داشتن یک متد با همان نام در یک trait و در نوعی دیگر وجود ندارد و همچنین راست مانع نمی‌شود که هر دو trait را بر روی یک نوع پیاده‌سازی کنید. همچنین می‌توانید متدی را مستقیماً بر روی نوعی پیاده‌سازی کنید که همان نام متدهای مربوط به traits را دارد.

هنگام فراخوانی متدهایی با همان نام، باید به راست بگویید که کدام یک را می‌خواهید استفاده کنید. کد زیر در فهرست 20-17 را در نظر بگیرید که در آن دو trait به نام‌های `Pilot` و `Wizard` تعریف شده‌اند که هر دو دارای متدی به نام `fly` هستند. سپس هر دو trait بر روی نوع `Human` پیاده‌سازی می‌شوند که قبلاً متدی به نام `fly` نیز بر روی آن پیاده‌سازی شده است. هر متد `fly` کاری متفاوت انجام می‌دهد.

<Listing number="20-17" file-name="src/main.rs" caption="دو trait تعریف شده‌اند که یک متد مشترک دارند و بر روی نوع `Human` پیاده‌سازی شده‌اند، و یک متد `fly` به‌طور مستقیم بر روی `Human` پیاده‌سازی شده است">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-17/src/main.rs:here}}
```

</Listing>

وقتی متد `fly` را بر روی یک نمونه از `Human` فراخوانی می‌کنیم، کامپایلر به طور پیش‌فرض متدی را که مستقیماً بر روی نوع پیاده‌سازی شده است، فراخوانی می‌کند، همان‌طور که در فهرست 20-18 نشان داده شده است.

<Listing number="20-18" file-name="src/main.rs" caption="فراخوانی `fly` بر روی یک نمونه از `Human`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-18/src/main.rs:here}}
```

</Listing>

اجرای این کد متن `*waving arms furiously*` را چاپ می‌کند و نشان می‌دهد که راست متد `fly` پیاده‌سازی‌شده بر روی `Human` را مستقیماً فراخوانی کرده است.

برای فراخوانی متدهای `fly` از `Pilot` یا `Wizard`، باید از سینتکس صریح‌تری برای مشخص کردن متدی که منظور ماست، استفاده کنیم. فهرست 20-19 این سینتکس را نشان می‌دهد.

<Listing number="20-19" file-name="src/main.rs" caption="مشخص کردن متد `fly` مربوط به کدام trait را می‌خواهیم فراخوانی کنیم">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-19/src/main.rs:here}}
```

</Listing>

مشخص کردن نام trait قبل از نام متد، به راست مشخص می‌کند که کدام پیاده‌سازی متد `fly` را می‌خواهیم فراخوانی کنیم. همچنین می‌توانیم `Human::fly(&person)` بنویسیم که معادل با `person.fly()` است که در فهرست 20-19 استفاده کرده‌ایم، اما اگر نیازی به رفع ابهام نباشد، این روش کمی طولانی‌تر است.

اجرای این کد خروجی زیر را چاپ می‌کند:

```console
{{#include ../listings/ch20-advanced-features/listing-20-19/output.txt}}
```

از آنجا که متد `fly` یک پارامتر `self` می‌گیرد، اگر دو _نوع_ داشته باشیم که یک _trait_ را پیاده‌سازی کنند، راست می‌تواند بر اساس نوع `self` مشخص کند که کدام پیاده‌سازی trait را باید استفاده کند.

با این حال، توابع مرتبطی که متد نیستند، پارامتر `self` ندارند. وقتی چندین نوع یا trait توابع غیر متد با یک نام مشترک تعریف می‌کنند، راست همیشه نمی‌داند که منظور شما کدام نوع است، مگر اینکه از _fully qualified syntax_ استفاده کنید. به عنوان مثال، در فهرست 20-20 ما یک trait برای یک پناهگاه حیوانات ایجاد می‌کنیم که می‌خواهد تمام سگ‌های کوچک را به نام _Spot_ نام‌گذاری کند. ما یک trait به نام `Animal` با یک تابع غیر متد مرتبط به نام `baby_name` تعریف می‌کنیم. trait `Animal` برای ساختار `Dog` پیاده‌سازی می‌شود، و همچنین یک تابع غیر متد مرتبط به نام `baby_name` مستقیماً بر روی `Dog` فراهم می‌کنیم.

<Listing number="20-20" file-name="src/main.rs" caption="یک trait با یک تابع مرتبط و یک نوع با یک تابع مرتبط با همان نام که همچنین trait را پیاده‌سازی می‌کند">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-20/src/main.rs}}
```

</Listing>

ما کدی برای نام‌گذاری تمام سگ‌های کوچک به نام Spot در تابع مرتبط `baby_name` که بر روی `Dog` تعریف شده است، پیاده‌سازی می‌کنیم. نوع `Dog` همچنین trait `Animal` را پیاده‌سازی می‌کند، که ویژگی‌هایی که تمام حیوانات دارند را توصیف می‌کند. سگ‌های کوچک به نام puppy شناخته می‌شوند و این در پیاده‌سازی trait `Animal` بر روی `Dog` در تابع `baby_name` مرتبط با trait `Animal` بیان شده است.

در تابع `main`، ما تابع `Dog::baby_name` را فراخوانی می‌کنیم، که تابع مرتبط تعریف شده بر روی `Dog` را مستقیماً فراخوانی می‌کند. این کد خروجی زیر را چاپ می‌کند:

```console
{{#include ../listings/ch20-advanced-features/listing-20-20/output.txt}}
```

این خروجی آن چیزی نیست که ما می‌خواستیم. ما می‌خواهیم تابع `baby_name` که بخشی از trait `Animal` است و بر روی `Dog` پیاده‌سازی شده است را فراخوانی کنیم تا کد `A baby dog is called a puppy` را چاپ کند. تکنیکی که در فهرست 20-19 برای مشخص کردن نام trait استفاده کردیم، اینجا کمکی نمی‌کند. اگر `main` را به کد موجود در فهرست 20-21 تغییر دهیم، خطای کامپایل دریافت خواهیم کرد.

<Listing number="20-21" file-name="src/main.rs" caption="تلاش برای فراخوانی تابع `baby_name` از trait `Animal`، اما راست نمی‌داند که از کدام پیاده‌سازی استفاده کند">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-21/src/main.rs:here}}
```

</Listing>

از آنجا که `Animal::baby_name` پارامتر `self` ندارد، و ممکن است انواع دیگری وجود داشته باشند که trait `Animal` را پیاده‌سازی کرده باشند، راست نمی‌تواند تشخیص دهد که کدام پیاده‌سازی از `Animal::baby_name` مورد نظر ما است. در نتیجه این خطای کامپایلر را دریافت خواهیم کرد:

```console
{{#include ../listings/ch20-advanced-features/listing-20-21/output.txt}}
```

برای رفع ابهام و مشخص کردن اینکه ما می‌خواهیم از پیاده‌سازی trait `Animal` برای `Dog` استفاده کنیم، به جای پیاده‌سازی trait `Animal` برای نوع دیگری، باید از fully qualified syntax استفاده کنیم. فهرست 20-22 نشان می‌دهد چگونه از fully qualified syntax استفاده کنیم.

<Listing number="20-22" file-name="src/main.rs" caption="استفاده از fully qualified syntax برای مشخص کردن اینکه می‌خواهیم تابع `baby_name` از trait `Animal` که بر روی `Dog` پیاده‌سازی شده است، فراخوانی کنیم">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-22/src/main.rs:here}}
```

</Listing>

ما با استفاده از یک اعلان نوع در داخل angle brackets به راست می‌گوییم که می‌خواهیم متد `baby_name` از trait `Animal` که بر روی `Dog` پیاده‌سازی شده است، فراخوانی شود، با این کار مشخص می‌کنیم که می‌خواهیم نوع `Dog` را برای این فراخوانی تابع به‌عنوان یک `Animal` در نظر بگیریم. این کد اکنون خروجی مورد نظر ما را چاپ می‌کند:

```console
{{#include ../listings/ch20-advanced-features/listing-20-22/output.txt}}
```

به طور کلی، fully qualified syntax به صورت زیر تعریف می‌شود:

```rust,ignore
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

برای توابع مرتبطی که متد نیستند، `receiver` وجود نخواهد داشت: فقط لیستی از آرگومان‌های دیگر خواهد بود. شما می‌توانید fully qualified syntax را در هر جایی که توابع یا متدها را فراخوانی می‌کنید، استفاده کنید. با این حال، مجاز هستید هر بخشی از این سینتکس را که راست می‌تواند از اطلاعات دیگر برنامه تشخیص دهد، حذف کنید. شما فقط در مواردی که چندین پیاده‌سازی با نام یکسان وجود دارد و راست به کمک نیاز دارد تا مشخص کند کدام پیاده‌سازی را می‌خواهید فراخوانی کنید، نیاز به استفاده از این سینتکس دقیق‌تر دارید.

### استفاده از Supertraits برای نیاز به قابلیت‌های یک trait درون trait دیگر

گاهی اوقات ممکن است یک تعریف trait بنویسید که به یک trait دیگر وابسته باشد: برای اینکه یک نوع بتواند اولین trait را پیاده‌سازی کند، می‌خواهید که آن نوع همچنین دومین trait را نیز پیاده‌سازی کند. این کار را انجام می‌دهید تا تعریف trait شما بتواند از آیتم‌های مرتبط trait دوم استفاده کند. trait‌ای که تعریف trait شما به آن متکی است، _supertrait_ نامیده می‌شود.

برای مثال، فرض کنید می‌خواهید یک trait به نام `OutlinePrint` بسازید که یک متد `outline_print` داشته باشد که یک مقدار داده شده را با فرمت مشخصی که در قاب ستاره‌ها قرار گرفته است، چاپ کند. به این صورت که اگر یک ساختار `Point` داشته باشیم که trait کتابخانه استاندارد `Display` را پیاده‌سازی کرده و نتیجه آن به شکل `(x, y)` باشد، وقتی متد `outline_print` را روی یک نمونه از `Point` که `1` برای `x` و `3` برای `y` دارد فراخوانی کنیم، باید خروجی زیر را چاپ کند:

```text
**********
*        *
* (1, 3) *
*        *
**********
```

در پیاده‌سازی متد `outline_print`، می‌خواهیم از قابلیت‌های trait `Display` استفاده کنیم. بنابراین، نیاز داریم مشخص کنیم که trait `OutlinePrint` فقط برای انواعی کار خواهد کرد که همچنین trait `Display` را پیاده‌سازی کرده باشند و قابلیت‌های مورد نیاز `OutlinePrint` را ارائه دهند. می‌توانیم این کار را در تعریف trait با مشخص کردن `OutlinePrint: Display` انجام دهیم. این تکنیک شبیه به اضافه کردن یک محدودیت trait به trait است. فهرست 20-23 یک پیاده‌سازی از trait `OutlinePrint` را نشان می‌دهد.

<Listing number="20-23" file-name="src/main.rs" caption="پیاده‌سازی trait `OutlinePrint` که نیاز به قابلیت‌های `Display` دارد">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-23/src/main.rs:here}}
```

</Listing>

از آنجایی که مشخص کرده‌ایم که `OutlinePrint` به trait `Display` نیاز دارد، می‌توانیم از تابع `to_string` استفاده کنیم که به طور خودکار برای هر نوعی که `Display` را پیاده‌سازی کرده باشد، پیاده‌سازی شده است. اگر سعی کنیم `to_string` را بدون اضافه کردن دو نقطه و مشخص کردن trait `Display` بعد از نام trait استفاده کنیم، خطایی دریافت خواهیم کرد که می‌گوید هیچ متدی به نام `to_string` برای نوع `&Self` در محدوده فعلی یافت نشد.

حالا ببینیم چه اتفاقی می‌افتد اگر بخواهیم `OutlinePrint` را برای یک نوعی که `Display` را پیاده‌سازی نکرده است، مانند ساختار `Point`، پیاده‌سازی کنیم:

<Listing file-name="src/main.rs">

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-02-impl-outlineprint-for-point/src/main.rs:here}}
```

</Listing>

خطایی دریافت می‌کنیم که می‌گوید `Display` مورد نیاز است ولی پیاده‌سازی نشده است:

```console
{{#include ../listings/ch20-advanced-features/no-listing-02-impl-outlineprint-for-point/output.txt}}
```

برای رفع این مشکل، باید `Display` را برای `Point` پیاده‌سازی کنیم و محدودیت مورد نیاز `OutlinePrint` را برآورده کنیم، به این صورت:

<Listing file-name="src/main.rs">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/no-listing-03-impl-display-for-point/src/main.rs:here}}
```

</Listing>

سپس با پیاده‌سازی trait `OutlinePrint` بر روی `Point`، کد با موفقیت کامپایل خواهد شد و می‌توانیم متد `outline_print` را روی یک نمونه از `Point` فراخوانی کنیم تا آن را در یک قاب ستاره‌ای نمایش دهد.

### استفاده از الگوی Newtype برای پیاده‌سازی Traits خارجی روی انواع خارجی

در فصل ۱۰ در بخش [“پیاده‌سازی یک Trait روی یک
نوع”][implementing-a-trait-on-a-type]<!-- ignore -->، به قانون orphan اشاره کردیم که بیان می‌کند ما فقط مجاز هستیم یک trait را روی یک نوع پیاده‌سازی کنیم اگر یا trait یا نوع به crate ما تعلق داشته باشد. با این حال، می‌توان با استفاده از _الگوی newtype_، این محدودیت را دور زد. این الگو شامل ایجاد یک نوع جدید در یک tuple struct است. (ما tuple struct‌ها را در بخش [“استفاده از Tuple Structs بدون فیلدهای نام‌گذاری‌شده برای ایجاد انواع مختلف”][tuple-structs]<!-- ignore --> در فصل ۵ پوشش دادیم.) tuple struct یک فیلد خواهد داشت و یک wrapper نازک دور نوعی خواهد بود که می‌خواهیم trait را برای آن پیاده‌سازی کنیم. سپس، نوع wrapper به crate ما تعلق دارد و می‌توانیم trait را روی wrapper پیاده‌سازی کنیم. اصطلاح _Newtype_ از زبان برنامه‌نویسی Haskell منشأ گرفته است. هیچ جریمه عملکردی در زمان اجرا برای استفاده از این الگو وجود ندارد و نوع wrapper در زمان کامپایل حذف می‌شود.

به‌عنوان مثال، فرض کنید می‌خواهیم `Display` را روی `Vec<T>` پیاده‌سازی کنیم، که قانون orphan مانع انجام این کار به‌صورت مستقیم می‌شود زیرا trait `Display` و نوع `Vec<T>` خارج از crate ما تعریف شده‌اند. می‌توانیم یک ساختار `Wrapper` بسازیم که شامل یک نمونه از `Vec<T>` باشد؛ سپس می‌توانیم `Display` را روی `Wrapper` پیاده‌سازی کنیم و از مقدار `Vec<T>` استفاده کنیم، همانطور که در فهرست 20-24 نشان داده شده است.

<Listing number="20-24" file-name="src/main.rs" caption="ایجاد نوع `Wrapper` دور `Vec<String>` برای پیاده‌سازی `Display`">

```rust
{{#rustdoc_include ../listings/ch20-advanced-features/listing-20-24/src/main.rs}}
```

</Listing>

پیاده‌سازی `Display` از `self.0` برای دسترسی به `Vec<T>` داخلی استفاده می‌کند، زیرا `Wrapper` یک tuple struct است و `Vec<T>` آیتمی در index صفر tuple است. سپس می‌توانیم از قابلیت‌های trait `Display` روی `Wrapper` استفاده کنیم.

عیب استفاده از این تکنیک این است که `Wrapper` یک نوع جدید است، بنابراین متدهای نوعی که درون خود نگه می‌دارد را ندارد. باید تمام متدهای `Vec<T>` را مستقیماً روی `Wrapper` پیاده‌سازی کنیم به طوری که متدها به `self.0` ارجاع دهند، که به ما اجازه می‌دهد `Wrapper` را دقیقاً مانند `Vec<T>` رفتار دهیم. اگر بخواهیم نوع جدید تمام متدهایی که نوع داخلی دارد را داشته باشد، پیاده‌سازی trait `Deref` (که در فصل ۱۵ در بخش [“رفتار با اشاره‌گر (Pointer)های هوشمند به‌عنوان ارجاعات معمولی با استفاده از trait `Deref`”][smart-pointer-deref]<!-- ignore --> بحث شد) روی `Wrapper` به‌گونه‌ای که نوع داخلی را بازگرداند، راه‌حلی خواهد بود. اگر نخواهیم نوع `Wrapper` تمام متدهای نوع داخلی را داشته باشد—برای مثال، برای محدود کردن رفتار نوع `Wrapper`—باید متدهایی که واقعاً نیاز داریم را به صورت دستی پیاده‌سازی کنیم.

این الگوی newtype حتی زمانی که traits درگیر نیستند نیز مفید است. حالا بیایید تمرکز خود را تغییر دهیم و به برخی از روش‌های پیشرفته برای تعامل با سیستم نوع Rust بپردازیم.

[newtype]: ch20-02-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types
[implementing-a-trait-on-a-type]: ch10-02-traits.html#implementing-a-trait-on-a-type
[traits-defining-shared-behavior]: ch10-02-traits.html#traits-defining-shared-behavior
[smart-pointer-deref]: ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait
[tuple-structs]: ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types
